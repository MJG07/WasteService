<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
        <!--
    <link rel="stylesheet" type="text/css" href="../css/issStyle1.css">
    <script type="text/javascript" src="../css/issStyle.js"></script>
    -->
    <style type="text/css">
    body
    {
        margin-left:  30px;
        margin-right: 30px;
    };

    P
    {
        font-family: Tahoma;
        font-size: 10pt;
    };

    a, a:visited, a:active, a:link, a:hover {
        text-decoration: underline;
        color: #545454;
        background-color: transparent;
        font-size: 93%;
    }

    a:hover {
        background-color: #cccccc;
    }


    hr {
        clear: both;
        height: 1px;
        color: #242424;
        background-color: transparent;
    }

    h1, h2, h3 {
        color: #242424;
        clear: left;
        font: 100% Tahoma, Helvetica, Arial, sans-serif;
        margin-bottom: 0.5em;
        padding-top: 0.5em;
        border-radius: 10px;
        padding: 5px;
    }

    top {
        width: 100%;
    }


    #i {
        color: #ff1010;
    }
    tt{
        font-family: "Arial";
        font-size: 90%;
        color: #006600;
    }
    em{
        font-family: "Arial";
        font-size: 80%;
        font-weight: bold;
        border-style:solid;
        border-color: #abe876;
        color: #1632cc;
    }
    bc{
        font-family: "Arial";
        font-size: 90%;
        font-weight: bold;
        color: #990000;
        background-color: #fcf8c7;
    }
    ks{
        font-family: "Arial";
        font-weight: bold;
        color: #0000CD	;
        font-size: 90%;
    }
    kc{
        font-family: "Arial";
        font-weight: bold;
        color: #008000	;
        font-size: 90%;
    }
    pre{
        font-family: "Consolas";
        font-size: 85%;
        background-color: #f5f5f5;
        border: 1.5px solid silver;
        padding: 5px;
    }
    m{
        font-family: "Helvetica";
        line-height: 100%;
        font-size: 75%;
    }
    div.body{
        
        font-size: 18px;
    }
    k{
        color: #990000;
        font-weight: bold;
        font-size: 90%;
    }
    h1 {
        font-size: 150%;
        background-color: #b2c0ff;
        padding: 10px;
    }

    h2 {
        background-color: #9ed8ff;
        font-size: 130%;
    }

    h3 {
        background-color: #e6ccff;
        font-size: 100%;
    }
    h4 {
        background-color: #ccffcc;
        font-size: 100%;
        width: 95%;
        border-radius: 5px;
        padding: 2px;
    }
    h5 {
        background-color: #d5ffb0;
        font-size: 100%;

    }
    div.req{
        background-color: #d9ffb3;
        font-size: 18px;
        width: 700px;
        border: 3px solid green;
        padding: 15px;
        margin: 10px;
    }
    div.remark{
        background-color: #E3F2FD;
        border: 1.5px solid #d5f2ed;
        padding: 15px;
        margin: 10px;
        border-radius: 25px;
    }
    table, th, td {
    border: 1px solid black;
    border-collapse: collapse;
    }

    ol, ul, li {
    margin: 0;
    margin-left: 10px;
    padding: 0;
    padding-bottom: 5px;
    }

    table, th, td {
        border: 1px solid black;
    }

    img {
        border: 1.5px solid #d5f2ed;
        

    }

    a, a:visited, a:active, a:link, a:hover {
        text-decoration: underline;
        color: #545454;
        background-color: transparent;
    }

    div.wrapdesc{
        width: 90%;
        margin: auto;
    }

    div.imagedesc{
        width: 85%;
        margin: auto;
    }
    </style>
        
    <head>
    <title>Qak</title>
    </head>

    <body>
        <div id="top">
        <h1>Riassunto QActor (meta)model </h1>
        </div>  
        
        <h2>I concetti espressi sono un riassunto della teoria espressa in questo link : <a href="http://htmlpreview.github.io/?https://github.com/anatali/issLab2022/blob/main/it.unibo.issLabStart/userDocs/Dispense/lezioni/html/QakIntro.html">QActor (meta)model</a></h2>
        
        <div class="remark">
            <h2>Introduzione</h2>
            <h3>
                Il <i> QActor (meta)model</i> è un linguaggio di modellazione per l'analisi e il progetto di applicazioni
                distribuite e per la definizioni di modelli di comportamento di attori di cui il comportamento sembra
                quello di una <i> Macchina a Stati Finiti</i>.
                Nello specifico noi utiliziamo il linguaggio <i> Qak</i> che implementa il linguaggio Kotlin, però senza usare un supporto <i>Akka.</i><br>
                Qusto linguaggio è definito mediante l'utilizzo del framework <i>Xtext</i> e si basa su un nucleo di concetti che compongono il metamodello.<br>
                <img src="img\qacontexts.png" alt="qacontexts"> <br>
                Questi concetti definiscono un QA-System cioè una collezione di entità, definiti Qactors, che interagiscono tra loro mediante <i>Messaggi (Dispatch, Request...)</i>.
                Essi possono inviarsi informazioni a vicenda e le operazioni di alto livello mediante i nomi degli attori, e possono cominicare con dispositivi "alieni"
                mediante protocolli TCP,CoAP, MQTT. <br>
                Il meta modello è supportata da un qak-infrastructure definita dal project it.unibo.qakactor e inserita nel it.unibo.qakactor-2.7.jar . <br>
                Definito un sistema con un nome qualsiasi, il Qak Software Factory genera due file <i>.pl</i> il primo con lo stesso nome del sistema genera i descrittori di quest'ultimo;
                il seondo invece, col nome <i>sysRules.pl</i> serve al QActor-infrastructure per avere conoscenza del sistema.
                Il concetto di qakactor è implementato dalla classe astratta  ActorBasic.kt, essa la implementa come un entita <i>message-driver</i> che gestisce i messaggi delegando il lavoro a un metodo astratto
                actorBody. In seguito verra estesa dalla classe ActorBasicFsm.kt, che le fornirà un comportamento di una FSM, essa è designata con gli stessi principi di una FSMKotlin. 
                L'actorBody supera la message-driven policy utilizzando un metodo fsmwork che implementa un comportamento di una FSM<br>
                <img src="img\ApplActorBasicFsm.png" alt="ApplActorBasicFsm">  
            </h3>
        </div>

        <div class="remark">
            <h2> <a href="http://htmlpreview.github.io/?https://github.com/anatali/issLab2022/blob/main/it.unibo.issLabStart/userDocs/Dispense/lezioni/html/QakIntro.htmlhtml#messages-and-events">Messages and Events</a> 
                 and 
                <a href="http://htmlpreview.github.io/?https://github.com/anatali/issLab2022/blob/main/it.unibo.issLabStart/userDocs/Dispense/lezioni/html/QakIntro.html#high-level-message-operations"> Higt-level message-operations</a>
            </h2>
            <h3>
              Nel metamodello QActor con messaggio si intende un invie di informazioni in modo asincrono da una sorgente ad un destinatario.
              Invece per evento si intende un informazione emessa da una sorgente senza che abbia un destinatario specifico. <br>
              Un messaggio contiene il tipo ApplMessage.kt (<a href="http://htmlpreview.github.io/?https://github.com/anatali/issLab2022/blob/main/it.unibo.issLabStart/userDocs/Dispense/lezioni/html/QakIntro.html#la-classe-applmessage">guarda ApplMessage</a>),
              e viene aiutata nel costruire e inviare i messaggi dalla classe : <i>MsgUtil.kt.</i>.
              Con il riferimento ad un user-defined QAkactor <i>qa</i> , un tipo di ActorBasicFsm, noi chiamiamo l'insieme di:
              <br>
              <ul>
                <li>currentState</li>
                <li>currentMsg</li>
                <li>kaq</li>
                <li>msgQueueStore</li>
                <li>tset</li>
              </ul>
              <br>
              Il metodo fsmwork è chiamato viene invocato dal kactor loop mentre il qa è in currentStare.
              
              <pre>
                suspend fun fsmwork(applMsg: ApplMessage) {
                    ... 
                    ...
                }
              </pre> 
              
              Il comportamento è:
              <ol>
                <li>qa controlla se ci sono transizioni relative a applMsg:
                    <ul>
                        <li>se c'è la possibilità di eseguire transazioni,<i> set currentMsg=applMsg</i>, cambia il currentState e va 2)</li>
                        <li>se non c'è la possibilità di eseguire transazioni, salva il messaggio in <i>msgQueueStore</i>;</li>
                    </ul>
                </li>
                <li>qa esegue le azioni dello stato e quando termina, se ci non c'è un empty-move va 3) altrimenti 4);</li>
                <li>qa esegue l'empty-move: <i>set currentMsg=NoMsg=noMsg</i>  , cambia il currentState, e va 2)</li>
                <li>qa guarda il msgQueueStore e:
                    <ul>
                        <li>se un messaggio ms isi trova in tset : <i> call fsmwork(ms)</i></li>
                        <li>se non ci sono messaggi : termina fsmwork </li>
                    </ul>
                </li>
              </ol>
              Un messaggio inviato da un attore ad un altro viene inserito nel kaq, invece un evento viene inviato da un contesto ad un altro e a tutti 
              i dispositivi "alieni" connessi mediate TCP o via MQTT.
              Quando invece un messaggio deve essere inviato da un attore ad un altro con contesto differente esso deve ottenere il suo <i>ipaddress-port</i>
              del contesto del ricevente, a meno che non sia una <i>reply</i>, ed esso può essere inviato con MQTT o CoAP
              Se un QActor che non utilizza MQTT non può propagare eventi e neanche riceverli.
              Un dispositivo "alieno" può emettere eventi che verranno percepiti dai QActors a cui sono collegati mediante TCP.
              I metodi di invio messaggi che un application designer può utilizzare sono:
              <ul>
                <li><i>forward</i> per i Dispatch</li>
                <li><i>request, replyTo, askFor</i> per una Request</li>
                <li><i>emit</i> per un Evento </li>
                Per quando riguarda le <i>Transition</i> sono eseguite se vi sono relative condizioni (<i> whenTime, whenEvent, whenMsg, ...</i>)
                insieme alle relative <i>guard</i>, se vere, cioè delle condizionidefinite da un codice Kotlin user-defined. 
              </ul>
            </h3>

        </div>

        <div class="remark">
            <h2>
                <a href="https://htmlpreview.github.io/?https://github.com/anatali/issLab2022/blob/main/it.unibo.issLabStart/userDocs/Dispense/lezioni/html/QakIntro.html#codedqactors">CodedQActors</a> 
            </h2>
            <h3>
                La Qak factory introduce un editor guidato dalla sintassi che facilita la scrittura di modelli in linguaggio QAk. Questa facilitazione è utile soprattutto 
                quando i modelli sono un risultato della analisi del problema e requisiti. In altre situazioni però, non è escluso che sia preferibile introdurre attori 
                scritti direttamente in Kotlin ed utlizzarli come una sorta di componenti predefiniti in modelli descritti in linguaggio QAk.
            </h3>
            <h2>
                <a href="http://htmlpreview.github.io/?https://github.com/anatali/issLab2022/blob/main/it.unibo.issLabStart/userDocs/Dispense/lezioni/html/QakIntro.html#sonar-come-codedqactor">Sonar come CodedQActor</a> 
            </h2>
            <h3>
                Si consideri ad esempio un sistema che deve utilizzare dati prodotti da un sonar ed è quindi logicamente composto da due componenti(sonarDataGen,datahandler).
                Entrambi questi componenti possono essere modellati come attori che interagiscono tramite eventi.
                <br>
                <img src="img\sonarDataGen.png" alt="sonarDataGen">
                <br>
                Un modello QAk del sistema può essere espresso come segue: <a href="">SonarQak</a>. In questo modello, 
                il sonar è introdotto come un CodedQActor di cui si specifica la classe che lo realizza.
                Un CodedQActor è un attore scritto in Kotlin che è definito come specializzazione di ActorBasic.
                Il QA-infrastructure gestisce il CodedQActor e "innietta" in esso un contesto specificato dal modello.
                Nelle fasi preliminari della costruzione di un sistema può essere opportuno introdurre un CodedQActor che realizza la simulazione di un Sonar, 
                focalizzando l’attenzione sulla informazione emessa come evento.
                Il modello che esprime la logica di funzionamento del gestore dei dati emessi 
                dal sonar è un attore che attiva il sonar inviando il dispatch start e poi attende gli eventi.
            </h3>
            <h2> <a href="http://htmlpreview.github.io/?https://github.com/anatali/issLab2022/blob/main/it.unibo.issLabStart/userDocs/Dispense/lezioni/html/QakIntro.html#qak-un-esempio-piu-articolato">QAk: un esempio più articolato</a> </h2>

            <h3> Qui sotto troviamo degli link ad esempi scpericifi di interazioni tra attori e come vengono modellati.
                <ul>
                    <li>
                        <a href="http://htmlpreview.github.io/?https://github.com/anatali/issLab2022/blob/main/it.unibo.issLabStart/userDocs/Dispense/lezioni/html/QakIntro.html#demo0-qak">demo0.qak</a>
                        Un esempio di modello che descrive una macchina a stati. 
                        <br>
                        <img src="img\demoDSL.png" alt="demoDSL">
                        <br>
                    </li>
                    <li>
                        <a href="http://htmlpreview.github.io/?https://github.com/anatali/issLab2022/blob/main/it.unibo.issLabStart/userDocs/Dispense/lezioni/html/QakIntro.html#demorequest-qak">demorequest.qak</a>
                        Un esempio di attere che invia una request a un altro attore locale e poi attende il messaggio di reply che avrà payload called_caller_hello.
                        <br>
                        <img src="img\demorequest.png" alt="demorequest">
                        <br>
                    </li>
                    <li>
                        <a href="http://htmlpreview.github.io/?https://github.com/anatali/issLab2022/blob/main/it.unibo.issLabStart/userDocs/Dispense/lezioni/html/QakIntro.html#demorequest-a-qak">demorequest_a.qak</a>
                        Un esempio di due attori che inviano richieste dello stesso tipo, ma con payload diverso ad un terzo attore, il quale invia la risposta all’attore chiamante.
                        <br>
                        <img src="img\demorequest_a.png" alt="demorequest_a">
                        <br>
                    </li>
                    <li>
                        <a href="http://htmlpreview.github.io/?https://github.com/anatali/issLab2022/blob/main/it.unibo.issLabStart/userDocs/Dispense/lezioni/html/QakIntro.html#demorequest-a-distribuito">demorequest_a distribuito</a>
                        Un esempio di modello ad attori distribuito, quindi vi è almeno un attore che non appartiene ad allo stesso contesto.
                        <br>
                        <img src="img\demorequest_aDistr1.png" alt="demorequest_aDistr1">
                        <br>
                    </li>
                </ul>
            </h3>

            <h2>
                <a href="http://htmlpreview.github.io/?https://github.com/anatali/issLab2022/blob/main/it.unibo.issLabStart/userDocs/Dispense/lezioni/html/QakIntro.html#externalqactor">ExternalQActor</a>
            </h2>
            <h3>
                Nell'esampio di un sistema distribuito vi sono situazioni in cui un sistema si configura e si costruisce ‘incrementalmente’, partendo da un nucleo iniziale e poi aggiungendo parti.
                Infatti supponiamo ad esempio di introdurre come ‘nucleo di base’ una risorsa modellata come segue.
                <br>
                <img src="img\resourcecore.png" alt="resourcecore">
                <br>
                Esso viene definito come <a href="http://htmlpreview.github.io/?https://github.com/anatali/issLab2022/blob/main/it.unibo.issLabStart/userDocs/Dispense/lezioni/html/QakIntro.html#resourcecore">resourcecore</a>.
                Ad esso si collega un ulteriore componente QakActor software che voglia 'fare sistema' con il resourcecore.
                <br>
                <img src="img\corecaller.png" alt="corecaller">
                <br>
                Ma per poter interagire deve conoscere il linguaggio di interazione cioè il protocollo utilizato per ricevere messaggi.
            </h3>
            <h2>
                <a href=http://htmlpreview.github.io/?https://github.com/anatali/issLab2022/blob/main/it.unibo.issLabStart/userDocs/Dispense/lezioni/html/QakIntro.html#actors-as-streams">Actors as streams</a>
            </h2>
            <h3>
                <a href="https://en.wikipedia.org/wiki/Reactive_programming">Reactive programming </a> è una combinazione della migliore idea di  Observer pattern, the Iterator pattern, e Functional programming.
                In Reactive programming, un consumatore reagisce ai dati non appena arrivano, con la capacità anche di propagare le modifiche come eventi agli osservatori registrati.
                Un QAkActor può lavorare come un produttore osservabile di dati; può essere osservato da altri attori che si colllegano presso di lui. Ciascun sottoscrittore elaborerà i dati ‘in parallelo’ 
                con gli altri e potrà a sua volta funzionare come osservabile.
            </h3>
            <h2>
                <a href="http://htmlpreview.github.io/?https://github.com/anatali/issLab2022/blob/main/it.unibo.issLabStart/userDocs/Dispense/lezioni/html/QakIntro.html#creazione-di-una-pipe">Creazione di una pipe</a>
            </h2>
            <h3>
                <br>
                <img src="img\sonarpipenano.png" alt="sonarpipenano">
                <br>
                In figura si vede un sitema che configura una pipe. I dati generati da <i>firstActorInPipe </i> 
                sono memorizzati dal <i>datalogger</i> , filtrati dal <i>datacleaner</i>  e gestiti dal <i>distancefilter</i> , 
                che emette l’evento <i>obstacle:obstacle(V)</i>  nel caso che il valore corrente della distanza 
                misurata risulti inferiore a un limite prefissato.
            </h3>
        </div>
    </body>
</html>